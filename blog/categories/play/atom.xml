<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Play | Joerg Viola]]></title>
  <link href="http://joergviola.github.com/blog/categories/play/atom.xml" rel="self"/>
  <link href="http://joergviola.github.com/"/>
  <updated>2012-12-01T13:09:04+01:00</updated>
  <id>http://joergviola.github.com/</id>
  <author>
    <name><![CDATA[Joerg Viola]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Play Meetings 2013]]></title>
    <link href="http://joergviola.github.com/blog/2012/11/30/play-meetings-2013/"/>
    <updated>2012-11-30T08:34:00+01:00</updated>
    <id>http://joergviola.github.com/blog/2012/11/30/play-meetings-2013</id>
    <content type="html"><![CDATA[<p>Is it only me? -
Where can I get a trusted list of all conferences, meetups, events, and beer-drinking
that are relevant to Play, Scala, Akka developpers?</p>

<p>Let's gather them here - drop a comment and I'll add your event!</p>

<!-- more -->


<ul>
<li><a href="http://www.devoxx.com/display/UK13/Home">Devoxx UK, London, March 26 - 27, 2013</a></li>
<li><a href="http://www.devoxx.fr/display/FR13/Home">Devoxx France, Paris, March 27 - 29, 2013</a></li>
<li><a href="http://jax.de/2013/">JAX, Mainz, April 22 - 26, 2013</a></li>
<li><a href="http://uberconf.com/conference/denver/2013/07/home">Ãœberconf, Denver, July 16 - 19, 2013</a></li>
<li><a href="http://webtechcon.de">WebTech, Mainz, October 13 - 16, 2013</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Page Driven Functional Tests for Play 2.0-Java]]></title>
    <link href="http://joergviola.github.com/blog/2012/06/04/page-driven-functional-tests-for-play-2-dot-0/"/>
    <updated>2012-06-04T20:44:00+02:00</updated>
    <id>http://joergviola.github.com/blog/2012/06/04/page-driven-functional-tests-for-play-2-dot-0</id>
    <content type="html"><![CDATA[<p>I proudly announce the first release (0.1) of funcy, a library for
Page Driven Functional Tests for Play 2.0-Java.</p>

<p><a href="https://github.com/joergviola/funcy">See GitHub for source and docu.</a></p>

<!-- more -->


<p>Functional Tests in Play 2.0 are the best way to test web applications:</p>

<ul>
<li>In standard web applications, you simply do not have really complex business logic. There is no point in using unit tests.</li>
<li>Selenium tests are hard to setup (even with Plays support), require explizit fixtures and they are very slow - too slow to be run before each commit.</li>
</ul>


<p>Example: Booking a ticket is fairly easy: Simply write a row into a database.
Whats the point of writing a unit test for that?</p>

<p>Building the booking form, receiving the request, validating user input, creating the ticket,
sending the confirmation mail and displaying the confirmation page, on the other hand, is quite a
complex process.</p>

<p>But testing it through selenium is hard and, if you run into the trap of recording your test cases,
very prone to changes of the underlying software.</p>

<p>Using Page Driven Play 2.0 Functional Tests provided by funcy, you can</p>

<ul>
<li>write your tests as simple unit tests</li>
<li>check results by accessing resulting web page DOMs or the database directly</li>
<li>run them very fast against an in-memory database.</li>
</ul>


<p>Consider this example:</p>

<p>``` java</p>

<pre><code>@Test
public void testBooking() {
    IndexPage indexPage = new IndexPage();
    EventPage eventPage = indexPage.clickEvent("Sidney Opera");
    BookingPage bookingPage = eventPage.book("2012/05/07");
    ConfirmationPage confirmationPage = bookingPage.book();

    List&lt;Booking&gt; bookings = Booking.all();
    Assert.assertEquals("#bookings", 1, bookings.size());
}
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A PDF module for Play 2.0 Java]]></title>
    <link href="http://joergviola.github.com/blog/2012/05/18/a-pdf-module-for-play-2-dot-0-java/"/>
    <updated>2012-05-18T23:48:00+02:00</updated>
    <id>http://joergviola.github.com/blog/2012/05/18/a-pdf-module-for-play-2-dot-0-java</id>
    <content type="html"><![CDATA[<p>Yup! I just created my first Play 2.0 module!
A lot of thanks to Steve for his tips for <a href="http://www.objectify.be/wordpress/?p=363">creating a module</a>
and <a href="http://www.objectify.be/wordpress/?p=410">publishing it on github pages</a>.</p>

<p>So finally here is a preliminary release of my PDF module.
It helps in generating PDF documents dynamically.
You simply create standard Play 2.0 html templates and render them as HTML.</p>

<!-- more -->


<p>As an example, see <a href="https://github.com/joergviola/play20-pdf/blob/master/samples/pdf-sample/app/views/document.scala.html">this template</a>:
``` html document.scala.html
@(message: String)</p>

<p>@main("Welcome to Play 2.0") {</p>

<pre><code>Image: &lt;img src="http://joergviola.github.com/public/images/favicon.png"/&gt;&lt;br/&gt;
Hello world! &lt;br/&gt;
@message &lt;br/&gt;
&lt;table border="1"&gt;
    &lt;tr&gt;
        &lt;td&gt;1&lt;/td&gt;
        &lt;td&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;3&lt;/td&gt;
        &lt;td&gt;4&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;
</code></pre>

<p>}
```
As you can see, it follows some simple rules:</p>

<ul>
<li>use XHTML</li>
<li>specify external links as filepathes into the classpath of your application.</li>
</ul>


<p>Then this template can simply be rendered as:
``` java</p>

<pre><code>public static Result document() {
    return PDF.ok(document.render("Your new application is ready."));
}
</code></pre>

<p><code>  
where</code>PDF.ok<code>is a simple shorthand notation for:
</code> java</p>

<pre><code>ok(PDF.toBytes(document.render("Your new application is ready."))).as("application/pdf")
</code></pre>

<p>```</p>

<p>In order to use that module, simply add to your Build.scala these lines:
``` java</p>

<pre><code>val appDependencies = Seq(
  "pdf" % "pdf_2.9.1" % "0.2",
  ...
)
val main = PlayProject(appName, appVersion, appDependencies, mainLang = JAVA, settings = s).settings(
        resolvers += Resolver.url("My GitHub Play Repository", url("http://www.joergviola.de/releases/"))(Resolver.ivyStylePatterns),
        ...
)
</code></pre>

<p>```
<a href="https://github.com/joergviola/play20-pdf">...and the Source is with You!</a></p>

<p>I am just starting to use this module, so I don't know how limited XHTML and CSS usage is.
Just let me know in the comments - thanks!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Why Scala templates rock]]></title>
    <link href="http://joergviola.github.com/blog/2012/05/12/why-scala-templates-rock/"/>
    <updated>2012-05-12T18:19:00+02:00</updated>
    <id>http://joergviola.github.com/blog/2012/05/12/why-scala-templates-rock</id>
    <content type="html"><![CDATA[<p>Play 2.0 uses Scala for HTML templates.
They are checked at compile-time, so you never again get ghostly errors in production
due to unforeseen situations.</p>

<p>But besides that, you can do other great things with ease.
Using a practical application of Scala functions for list pagination, for example.</p>

<!-- more -->


<h2>Pagination with EBean</h2>

<p>The EBean ORM used by Play 2.0 provides tools for very simply querying for paginated lists.
Since our web application is about seminars, we have e.g. this accessor for top rated seminars:
``` java Seminar.java
public static Page<Seminar> top(int size, int page) {</p>

<pre><code>return find.where().orderBy("rating desc")
       .findPagingList(size).getPage(page);
</code></pre>

<p><code>
This can be used by our `Publics` controller to render a page of top rated seminars:
</code> java Publics.java
public static Result top(int page) {</p>

<pre><code>return ok(top.render(Seminar.top(10, page)));
</code></pre>

<p>}
<code>
The template for rendering this list is very simple:
</code> html top.scala.html
@(seminars : Page[Seminar])</p>

<p>@for(seminar &lt;- seminars.getList){</p>

<pre><code>@seminarInList(seminar)
</code></pre>

<p>} <br/>
<code>
and pagination is added equally simple:
</code> html seminarList.scala.html
@if(seminars.getTotalPageCount>1){</p>

<pre><code>@if(seminars.hasPrev) {
    &lt;a href="@routes.Publics.top(seminars.getPageIndex - 1)"&gt;&amp;larr;&lt;/a&gt;
} else {
    &amp;larr;
}
@for(p &lt;- 1 to page.getTotalPageCount) {
    @if(p-1==seminars.getPageIndex) {
        @p
    } else {
        &lt;a href="@routes.Publics.top(p-1)"&gt;@p&lt;/a&gt;
    }
}
@if(seminars.hasNext) {
    &lt;a href="@routes.Publics.top(seminars.getPageIndex + 1)"&gt;&amp;rarr;&lt;/a&gt;
} else {
    &amp;rarr;
}
</code></pre>

<p>} <br/>
```</p>

<h2>Add flexibility with Scala functions</h2>

<p>As you can image, we have all kind of seminar lists: Top rated, newest, in one category and so on.
We would of course very much like to have a sub-template capable of rendering any list of seminars.
But the pagination links then have to be customized.</p>

<p>This can be done easily using Scala functions:
The method of the router representing the link in Scala reads <code>routes.Publics.top(page:Int):Call</code>.
Applying the Scala wildcard <code>_</code> to it like in <code>routes.Publics.top(_)</code> creates a Scala function
mapping an Int to a Call: <code>Int =&gt; Call</code>. Functions of this type are exactly the parameters we want to have
in a generalized seminar list template:
``` html seminarList.scala.html
@(seminars : Page[Seminar], link: Int => Call)</p>

<p>@for(seminar &lt;- seminars.getList){</p>

<pre><code>@seminarInList(seminar)
</code></pre>

<p>} <br/>
<code>
because the pagination can then make simple use of it:
</code> html seminarList.scala.html
@if(seminars.getTotalPageCount>1){</p>

<pre><code>@if(seminars.hasPrev) {
    &lt;a href="@link(seminars.getPageIndex - 1)"&gt;&amp;larr;&lt;/a&gt;
} else {
    &amp;larr;
}
@for(p &lt;- 1 to page.getTotalPageCount) {
    @if(p-1==seminars.getPageIndex) {
        @p
    } else {
        &lt;a href="@link(p-1)"&gt;@p&lt;/a&gt;
    }
}
@if(seminars.hasNext) {
    &lt;a href="@link(seminars.getPageIndex + 1)"&gt;&amp;rarr;&lt;/a&gt;
} else {
    &amp;rarr;
}
</code></pre>

<p>} <br/>
<code>
This sub-template can then simply be called like:
</code> html top.scala.html
@seminarList(top, routes.Publics.top(<em>))  <br/>
<code>
or
</code> html newest.scala.html
@seminarList(newest, routes.Publics.news(</em>))  <br/>
```</p>

<p>Scala templates rock!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Upgrading to Play 2.0.1]]></title>
    <link href="http://joergviola.github.com/blog/2012/05/11/upgrading-to-play-2-dot-0-1/"/>
    <updated>2012-05-11T08:31:00+02:00</updated>
    <id>http://joergviola.github.com/blog/2012/05/11/upgrading-to-play-2-dot-0-1</id>
    <content type="html"><![CDATA[<p>Play 2.0.1 is here!
Learn how to upgrade and what to gain.</p>

<!-- more -->


<h2>What to gain</h2>

<p><a href="https://groups.google.com/forum/?fromgroups#!searchin/play-framework/2.0.1$20is$20ready/play-framework/XtJk-LFBtCw/uIqCZxpzG-wJ">Here</a>
is the announcement.</p>

<p>For me, the following enhancements are important:</p>

<ul>
<li>EBean enhancement seems to be fixed - no enhancement errors until now.</li>
<li>more efficient sbt dependency check - the number of files that are compiled after a change
seems to have been reduced. That improves turn-around speed a lot.</li>
</ul>


<h2>How to upgrade</h2>

<ol>
<li>Download <a href="http://download.playframework.org/releases/play-2.0.1.zip">Play 2.0.1</a></li>
<li>Unzip and move to $SOMEDIR/play-2.0.1</li>
<li>Add to $PATH: $SOMEDIR/play-2.0.1, removing your play-2.0-setting</li>
<li><p>Update project/plugins.sbt to include</p>

<pre><code> addSbtPlugin("play" % "sbt-plugin" % "2.0.1")
</code></pre></li>
<li><p>If you had tweaked your Build.scala to path the ebean enhancement, reset it to something like the following:</p>

<pre><code> import sbt._
 import Keys._
 import PlayProject._

 object ApplicationBuild extends Build {

     val appName         = "66and33-web"
     val appVersion      = "1.0-SNAPSHOT"

     val appDependencies = Seq(
       "postgresql" % "postgresql" % "8.4-702.jdbc4"
     )
     val main = PlayProject(appName, appVersion, appDependencies, mainLang = JAVA).settings(
             templatesImport += "util._"
     )

 }
</code></pre></li>
<li><p>run <code>play eclipsify</code></p></li>
<li>as in 2.0, tweak the generated project by

<ol>
<li>removing the output folders on the source folders ./app and ./test. The effectively tells eclipse to compile into ./bin
which does not interfere with the sbt compilation</li>
<li>add target/scala-2.9.1/classes to your build path. This allows access e.g. to the ReverseControllers</li>
</ol>
</li>
</ol>

]]></content>
  </entry>
  
</feed>
